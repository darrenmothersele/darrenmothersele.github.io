<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>How to do Everything with PHP Middleware (DrupalCamp London) | Darren Mothersele</title>
  <link rel="stylesheet" href="/css/styles.css">
</head>
<body>

<div class="home-logo">
  <a href="/">
<img src="/img/daz-logo.png" alt="Daz Logo" class="home-logo-img">
</a>
</div>

<hgroup class="alignCenter">
  <h1>How to do Everything with PHP Middleware (DrupalCamp London)</h1>
        <h6>Mar 28, 2017 · By Darren Mothersele</h6>
  <p class="sc">Web Dev</p>
</hgroup>
<p>At the DrupalCamp in London earlier this month I gave a talk 
about PHP Middleware. 
You can see a <a href="https://www.youtube.com/watch?v=I0pXXCQdHQM">recording of the talk</a> 
on YouTube. Here’s a summary, in case you don’t want to watch 
the whole talk, or the distorted audio upsets you, or if you 
want the links and references:</p>

<h2 id="simple-vs-easy">Simple vs Easy</h2>

<p>I started with a reference to the important talk by Rich Hickey, 
<a href="https://www.infoq.com/presentations/Simple-Made-Easy">Simple Made Easy</a>.
This is high up on my list of videos every software developer needs to watch.
I began here because I think it’s important to identify the difference
between <em>simple</em> and <em>easy</em>, to identify where complexity sneaks into our 
systems. I have found PHP Middleware to be an important tool in 
the fight against complexity.</p>

<blockquote>
  <p>“programming, when stripped of all its circumstantial irrelevancies, boils 
down to no more and no less than very effective thinking so as to avoid 
unmastered complexity, to very vigorous separation of your many different concerns.</p>

  <p>– <a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD05xx/EWD512.html">Edsgar W. Dijkstra</a> (1930 - 2002)</p>
</blockquote>

<h2 id="de-complecting-php">De-complecting PHP</h2>

<p>I talked a bit about different ways to simplify development with PHP.
Including: Domain-driven design, Hexagonal architecture (Ports and 
Adapters), Framework-independent code, Thin APIs, etc…
In particular, I wanted to emphasise the importance of framework-independent
code and the benefit of using common interfaces such as the ones developed
as PSRs by <a href="http://www.php-fig.org/">PHP-FIG</a>.</p>

<p>There was some discussion after about introducing unecessary abstractions,
but I think this misses the point. Of course there is a trade off, but the
key is to focus on the simplicity, on <em>untwisting</em> things (c.f. Rich Hickey).</p>

<h2 id="de-coupled">De-coupled</h2>

<p>Inspired by the <a href="https://docs.zendframework.com/zend-expressive/">Zend Expressive</a>
installation procedure, I imagined what Drupal 10 might look like, with 
fully-decoupled components.</p>

<p><img src="http://www.darrenmothersele.com/img/drupal-x-installer.jpg" alt="Drupal Install" /></p>

<h2 id="interfaces">Interfaces</h2>

<p>The widespread adoption of PSR7 by the PHP community has lead to the 
popularity of PHP Middleware-based systems.</p>

<p>Why PSR7 when Symfony HTTP components were so popular?
Well, that is an implementation - and rather than standardise on 
implementation, we should standardise against interfaces.</p>

<p>This allows more interoperability. I showed this <strong>pseudocode</strong>:</p>

<div class="language-php highlighter-rouge"><pre class="highlight"><code>// Take the incoming request from Diactoros
$request = ServerRequestFactory::fromGlobals();

$client = new Client();

// Response comes back from Guzzle
$response = $client-&gt;send($request-&gt;withUrl($dest));

$body  = simplexml_load_string(
$response-&gt;getBody()-&gt;getContents());

// pass back to Diactoros
(new SapiEmitter)-&gt;emit($response-&gt;withBody($body));
</code></pre>
</div>

<p>The example uses HTTP requests from 
<a href="https://github.com/zendframework/zend-diactoros">Zend Diactoros</a>,
forwards them using the <a href="http://guzzle.readthedocs.io/en/latest/">Guzzle</a>
HTTP client, and returns the response object from Guzzle
using the SAPI Emitter from Diactoros.</p>

<p>This demonstrates the power of sharing standard interfaces.
Here two packages are used together, both provide
an implementation of PSR7 HTTP messages, and they
work seamlessly because they both conform to the same interface,
despite the differing implementation details.</p>

<h2 id="decorating-web-apps">Decorating Web Apps</h2>

<p>This is what a typical web app looks like:</p>

<p><img src="http://www.darrenmothersele.com/img/ball-of-mud.jpg" alt="Ball of Mud" /></p>

<p>Which can be simplified to this:</p>

<p><img src="http://www.darrenmothersele.com/img/web-app-1.png" alt="Web App" /></p>

<p>A web app takes a request and returns a response.</p>

<p>The concept behind PHP Middleware is that you can <em>decorate</em>
the app, to add new functionality, by intercepting the request
on the way in, and the response on the way out.
This avoids the complexity of <em>intertwining</em> your code
throughout the ball of mud.</p>

<p><img src="http://www.darrenmothersele.com/img/web-app-2.png" alt="Web App" /></p>

<p>Here’s an example (pseudocode) for adding CORS 
functionality to an existing app:</p>

<div class="language-php highlighter-rouge"><pre class="highlight"><code>
$cors = analyze($request);
switch ($cors-&gt;getRequestType()) {
    Case ERR_NO_HOST_HEADER:
    Case ERR_ORIGIN_NOT_ALLOWED:
    Case ERR_METHOD_NOT_SUPPORTED:
    Case ERR_HEADERS_NOT_SUPPORTED:
        Return createResponse(403);

    Case TYPE_REQUEST_OUT_OF_CORS_SCOPE:
        return $APP-&gt;process($request);

    Case TYPE_PRE_FLIGHT_REQUEST:
        $response = Utils\Factory::createResponse(200);
        Return $response-&gt;withHeaders($cors-&gt;getHeaders);

    default:
        $response = $APP-&gt;process($request);
        Return $response-&gt;withHeaders($cors-&gt;getHeaders);
}

</code></pre>
</div>

<p><a href="http://stackphp.com/">StackPHP</a> first popularised the concept of middleware
in PHP. This diagram is from their website:</p>

<p><img src="http://www.darrenmothersele.com/img/onion.png" alt="Web App" /></p>

<p>There are other popular micro-frameworks based on this concept,
such as <a href="https://www.slimframework.com/">Slim</a>.</p>

<p>The core of your app is just a thin layer of business logic. 
Just your domain specific code. The rest can be wrapped in layers
which isolate and separate concerns nicely.</p>

<h2 id="single-pass-vs-double-pass">Single-pass vs Double-pass</h2>

<p>The <em>double pass</em> approach became the most popularly used
signature for HTTP middleware, based on
<a href="http://expressjs.com/en/guide/writing-middleware.html">Express middleware</a>
from the JS community.</p>

<p>It looks like this:</p>

<div class="language-php highlighter-rouge"><pre class="highlight"><code>// DOUBLE PASS
function __invoke($request, $response, $next) {
}
</code></pre>
</div>

<p>The request and the response are both passed into the middleware,
along with a <code class="highlighter-rouge">$next</code> delegate that is called to pass
control and carry on processing down the chain of middleware.</p>

<p>This double-pass approach is much newer, but 
used by most of the early adopters of PSR-7.</p>

<p>A single pass approach, looks like this:</p>

<div class="language-php highlighter-rouge"><pre class="highlight"><code>// SINGLE PASS / LAMBDA
function process($request, $delegate) {
}
</code></pre>
</div>

<p>The issue is with how the response object is dealt with.
In the double-pass approach, both are provided. 
The argument is that this is better for dependency 
inversion. Using the single pass approach you either
need to hard code a dependency on a HTTP message 
implementation into your middleware when the response
is required, or you need to inject a factory for
generating the response.</p>

<h2 id="psr-15-http-middleware">PSR-15 HTTP Middleware</h2>

<p>After the success of PSR7, with it’s wide adoption leading to
much standardisation and interoperability in PHP frameworks,
the next step is to standardise the middleware interface.</p>

<p>This is not yet an accepted PSR. At the time of writing 
it is still in <strong>draft</strong> status.
It is available for use in the 
<a href="https://github.com/http-interop/http-middleware">http-interop/http-middleware</a> repo.</p>

<h2 id="invoker">Invoker</h2>

<p>As an aside, I mentioned the <a href="https://github.com/PHP-DI/Invoker">Invoker Interface</a>.
As per the docs:</p>

<blockquote>
  <p>“Who doesn’t need an over-engineered call_user_func()?”</p>
</blockquote>

<p>In particular this library really simplifies the process
of calling things and injecting dependencies. 
It also allows to call things using named parameters.
I make extensive use of this, and I find making calls with 
named parameters makes code much easier to understand.</p>

<h2 id="psr-15-interfaces">PSR-15 Interfaces</h2>

<p>PSR-15 has two interfaces. Both define a method called <code class="highlighter-rouge">process</code>.
One is the signature that middleware must support, which takes
a PSR7 request and a PSR15 delegate. The other interface defines
the <code class="highlighter-rouge">process</code> method for the delegate. The method on both
interfaces is defined as returning a PSR7 response.</p>

<p><img src="http://www.darrenmothersele.com/img/psr-15.png" alt="Web App" /></p>

<p>So you can compose a chain of middleware, pass in a request
and get a response. The request is passed down the chain of 
middleware until a response is generated which is then passed
back up the chain, possibly being decorated along the way.</p>

<p>For want of a better name, I refer to this chain of middleware
as a <em>stack</em>. And, I have created a simple 
<a href="https://github.com/ideationnet/stack-runner">Stack Runner</a> to 
handle the processing of a stack of PSR-15 middleware.</p>

<div class="language-php highlighter-rouge"><pre class="highlight"><code>class StackRunner implements DelegateInterface
{
    public function __construct(
   array $stack,
        InvokerInterface $invoker,
        ResponseFactoryInterface $responseFactory
    ) { ... }

    public function process(ServerRequestInterface $request)
    {
        if (!isset($this-&gt;stack[$this-&gt;current])) {
            return $this-&gt;responseFactory-&gt;createResponse();
        }
        $middleware = $this-&gt;stack[$this-&gt;current];
        $this-&gt;current++;

        return $this-&gt;invoker-&gt;call([$middleware, 'process'], [
            'request' =&gt; $request,
            'delegate' =&gt; $this,
        ]);
    }
}
</code></pre>
</div>

<h2 id="adr-action-domain-responder">ADR (Action Domain Responder)</h2>

<p>I went on to talk about ADR as being an adaptation of MVC that
is more suitable for use in Web Apps.
I’ve found this particularly useful when using Domain-Driven Design,
or when used to create <em>thin APIs</em> where you
have just a thin layer of business logic on top of a data store.</p>

<p>The issue with MVC is that the template is not the view. 
The <em>“view”</em> of a web app is the HTTP response, and we split this
across our layers, as the body of the response is typically generated
by the view, with the knowledge of HTTP being encoded into our controllers.
We also bundle together various actions into one controller, which 
means instantiating the whole thing when we want to run one of the actions.</p>

<p>ADR offers an alternative separation of concerns, where the
action methods of the controller are their own separate classes 
(or in my case anything <em>invokable</em> via the <code class="highlighter-rouge">InvokerInterface</code>).
I use an <code class="highlighter-rouge">InputHandler</code> to deal with parsing the input from the HTTP Request, 
which the Invoker can then use (via the magic of named arguments).</p>

<p>The domain (Model in MVC terminology) is where the business logic lives.
This is called domain, rather than model, to suggest use of
domain-driven design.</p>

<p>To use ADR with PHP Middleware, add a <em>resolver</em> to the end of the
chain of middleware to <em>dispatch</em> the request to the appropriate 
<code class="highlighter-rouge">Action</code>.</p>

<p><img src="http://www.darrenmothersele.com/img/radr.png" alt="Web App" /></p>

<h2 id="action">Action</h2>

<p>I’ve created a reference implementation of an <em>invokable</em>
<a href="https://github.com/ideationnet/wafer/blob/master/src/Action.php">Action</a>.</p>

<p><img src="http://www.darrenmothersele.com/img/action.png" alt="Web App" /></p>

<h2 id="demo">Demo!</h2>

<p>At this point in my talk I planned to give a demo of 
how you compose ADR with Middleware to create a working API.
Unfortunately, I had some tech issues getting my computer linked
up to the projector, and I was starting to feel really ill (full of 
cold). By this time the caffeine was starting to wear off, and 
I needed the talk to end!</p>

<p>I’ve put the example code up in a 
<a href="https://github.com/darrenmothersele/dcldn2017">GitHub repo</a>.</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://www.infoq.com/presentations/Simple-Made-Easy">Simple Made Easy</a> - talk by Rich Hickey</li>
  <li><a href="https://github.com/http-interop/http-middleware">HTTP Middleware</a> and
<a href="https://github.com/http-interop/http-factory">HTTP Factory</a> interfaces.</li>
  <li><a href="https://github.com/middlewares/psr15-middlewares">PSR15 Middlewares</a> a
set of really useful middlewares that can be used with a PSR15 middleware 
dispatcher.</li>
  <li><a href="https://github.com/ideationnet/stack-runner">Stack Runner</a> 
my reference implementation of a <em>very</em> simple stack runner for executing
a chain of PSR15 middleware.</li>
  <li><a href="https://github.com/ideationnet/wafer">Wafer</a> an experimental implementation
of the ADR idea to be used along with PSR15 middleware and the stack runner.</li>
</ul>

<p>Drop me a line with any feedback. Thanks!</p>




<div class="author-line">

  <figure class="author-image">
    <img src="/img/darren100.jpg" alt="Darren's Photo" class="avatar">
  </figure>

<h4>Darren Mothersele</h4>
<p>Darren is a software developer who builds simple, creative, and independent technology. <a href="/about">Read more &raquo;</a></p>
</div>




<footer>
  <p>Want to support my work? Buy my <a href="/blog/2016/06/16/php-framework-weekend/">PHP Framework</a> book.
  Available in paperback from <a href="http://amzn.to/2bNv560">Amazon</a> or eBook from <a href="https://leanpub.com/phpframework">Leanpub</a>.</p>
  <p>
    <small>
      &copy;2007-2016 <a href="/about">Darren Mothersele</a>.
        <a class="text-white" href="http://creativecommons.org/licenses/by-sa/4.0/">Some rights reserved</a>.
        <a href="/contact">Contact</a>.
        <a href="/blog/">Blog Archive</a>.
    </small>
  </p>
</footer>
</body>
</html>
