<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Tiny PHP Micro-Framework in 40 Lines of Code | Darren Mothersele</title>
  <link rel="stylesheet" href="/css/styles.css">
</head>
<body>

<div class="home-logo">
  <a href="/">
<img src="/img/daz-logo.png" alt="Daz Logo" class="home-logo-img">
</a>
</div>

<hgroup class="alignCenter">
  <h1>Tiny PHP Micro-Framework in 40 Lines of Code</h1>
        <h6>Sep 1, 2016 · By Darren Mothersele</h6>
  <p class="sc">Web Dev</p>
</hgroup>
<p>One of the projects I’m working on at the moment is a very simple
interface to Amazon’s transcoding service. 
It’s a very basic site, and a great example to learn Angular 2.
I needed to create a simple backend that would authenticate the user
and proxy requests to the AWS Transcoding API, adding in some 
pre-configured settings.</p>

<p>Setting up a Drupal 8 site and configuring the rest API would have 
been massively overkill for this. Even using a Express (Node.js) 
or any PHP Microframework seemed like overkill. This seemed like
a good excuse for an experiment with modern PHP.</p>

<p>I could have quite easily put all the code to do this in one 
file, but that’s not the modern PHP way. I’ve found the most 
important rule to follow to curb PHP complexity is the 
<strong>single responsibility principle</strong>. Each file will do one thing.
Each block of code has a single responsibility. Each class 
encapsulates one thing.</p>

<p>Here’s the code in it’s entirety. The astute among you may recognise this
as a middleware dispatcher, like Slim, Stack, or Relay.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>use DI\InvokerInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;

class StackRunner
{
    /** @var InvokerInterface */
    protected $invoker;

    protected $stack = [];
    protected $current = 0;

    public function __construct(InvokerInterface $invoker, $stack)
    {
        $this-&gt;invoker = $invoker;
        $this-&gt;stack = $stack;
    }

    public function __invoke(ServerRequestInterface $request, ResponseInterface $response)
    {
        if (!isset($this-&gt;stack[$this-&gt;current])) {
            return $response;
        }

        $middleware = $this-&gt;stack[$this-&gt;current];
        $this-&gt;current++;

        return $this-&gt;invoker-&gt;call($middleware, [
          'request' =&gt; $request,
          'response' =&gt; $response,
          'next' =&gt; $this,
        ]);
    }
}
</code></pre>
</div>

<p>That’s it. Less than 40 lines of code.</p>

<p>Even Harmony (a similar lightweight no-framework) clocks in at over 4 times the
size at 200 lines.</p>

<p>Let’s have a look at what it’s doing, and how to use it.</p>

<p>Stack has a diagram that shows how the middleware dispatcher idea works.
http://stackphp.com/ They refer to this as an onion.
<img src="/img/onion.png" /></p>

<p><strong>NB</strong>: Ignore the session layer. I’m building a restful API, and restful
APIs should not have state. Yes, most people are doing REST wrong. 
One of the six constraints for a REST architecture is statelessness.</p>

<p>In this model you build up a <em>stack</em> of middleware, then pass the request 
through each one, then pass the response back out through each layer. 
Each layer in the stack gets to process the request and response as they
travel into the core of the app, and then back out again.</p>

<p>The core of the app is your business logic. Everything is separated
into layers, and each can be tested and reasoned about in isolation.</p>

<p>Your stack of middleware is injected into the stack
runner as a dependency via the constructor, along with an instance
of an implementation of the <code class="highlighter-rouge">InvokerInterface</code>.
In my case I’m using PHP-DI as a dependency injection container
and it’s container implements the required interface. 
The interface just provides a <code class="highlighter-rouge">call()</code> method that given a 
PHP callable (or string registered in the container) 
instantiates the callable (if required) and uses the container
to provide any arguments.</p>

<p>This class produces an invokable object. When invoked
the stack of middleware is traversed, executing each one
and passing along the stack so that execution can continue.
The implementation of the <code class="highlighter-rouge">__invoke()</code> method does this
and has just 3 simple sections.</p>

<p>1) First it checks to see if it has reached the end of the stack
of middlware. In which case it just returns the current
<code class="highlighter-rouge">$response</code> so that it can travel back up the stack.</p>

<p>2) If not at the end of the stack, the current middleware
is retrieved from the stack and the stack pointer 
(<code class="highlighter-rouge">$this-&gt;current</code>) is moved along to the next middleware.</p>

<p>3) The InvokerInterface is used to call the middlware,
passing in the <code>$request</code>, <code class="highlighter-rouge">$response</code>, and the
stack runner as <code class="highlighter-rouge">$next</code> so that it can be called
from within the middleware to continue execution along
the rest of the stack.</p>

<p>So, how do you make use of this?</p>

<p>Well, you need a few things to make it work.
As you can see in the code above, it’s programmed against
interfaces from PSR-7. This is the PHP-FIG (Framework
interoperabilirty group) effort to standardise the
Request and Response object interfaces. 
Any implementation of PSR-7 will do, for example
the Diactoros package from Zend.</p>

<p>You also need to register your dependencies with 
a PHP-DI container and provide that to the constructor.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$stack = [ExampleMiddleware::class]
$builder = new ContainerBuilder;
$container = $builder-&gt;build();
$runner = new StackRunner($container, $stack);
$response = $runner($request, $response);
</code></pre>
</div>

<p>So what does a middleware in this stack look like?</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class ExampleMiddleware
{
    public function __invoke($request, $response, $next)
    {
    	// 1. optionally do something with $request

   		// 2. continue execution down the stack
        $response = $next($request, $response);

        // 3. optionally do something with $response

        // 4. return $response
        return $response;
    }
}
</code></pre>
</div>




<div class="author-line">

  <figure class="author-image">
    <img src="/img/darren100.jpg" alt="Darren's Photo" class="avatar">
  </figure>

<h4>Darren Mothersele</h4>
<p>Darren is a software developer who builds simple, creative, and independent technology. He believes this will empower humans to create a better future. <a href="/about">Read more &raquo;</a></p>
</div>




<footer>
  <p>Want to support my work? Buy my <a href="/blog/2016/06/16/php-framework-weekend/">PHP Framework</a> book.
  Available in paperback from <a href="http://amzn.to/2bNv560">Amazon</a> or eBook from <a href="https://leanpub.com/phpframework">Leanpub</a>.</p>
  <p>
    <small>
      &copy;2007-2016 <a href="/about">Darren Mothersele</a>.
        <a class="text-white" href="http://creativecommons.org/licenses/by-sa/4.0/">Some rights reserved</a>.
        <a href="/contact">Contact</a>.
        <a href="/blog/">Blog Archive</a>.
    </small>
  </p>
</footer>
</body>
</html>
