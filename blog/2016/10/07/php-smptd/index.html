<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Simple SMTP Server in PHP | Darren Mothersele</title>
  <link rel="stylesheet" href="/css/styles.css">
</head>
<body>

<div class="home-logo">
  <a href="/">
<img src="/img/daz-logo.png" alt="Daz Logo" class="home-logo-img">
</a>
</div>

<hgroup class="alignCenter">
  <h1>Simple SMTP Server in PHP</h1>
        <h6>Oct 7, 2016 · By Darren Mothersele</h6>
  <p class="sc">Web Dev</p>
</hgroup>
<p class="attention-grabber">
In this post I will explain why I wrote an SMTP server,
why I used PHP to do it, how SMTP works, and show code that
receives emails in PHP.
</p>

<blockquote>
  <p>“Email is super broken, but I’d still rather use a system
that’s weird because it was built for 60s neckbeards than
one built for advertisers.” <a href="https://twitter.com/xor/status/780848559092490240">@xor</a></p>
</blockquote>

<h2 id="why-smtp">Why SMTP?</h2>

<p>Why did I decide to write an smtp server? Email’s not cool, right?
There’s a multitude of messaging and chat apps available.
Many of them are built with modern web technologies.
Many of them offer end-to-end encryption, friction-less sharing,
tight integration with our devices, and an easy to use, spam-free
experience.
Surely a better investment of my time would be to learn how to
write chatbots? With all these new options available, why would
I bother taking a deep-dive into a technology that’s older than me?
It occurred to me while researching this, that I was only three
years old when the first RFC for the
<em>simple mail transfer protocol</em> was published in 1982.</p>

<p>I made this timeline that shows the development of SMTP…</p>

<div class="figure">
<img src="/img/smtp/smtp-history.png" alt="smtp timeline" />
</div>

<p>New messaging apps keep appearing: Facebook Messenger, WhatsApp,
WeChat, Line, Viber, Telegram, Signal, Slack, Skype.
Many of them (<a href="https://www.fastcompany.com/3015730/innovation-agents/flickr-cofounders-launch-slack-an-email-killer">Slack</a>), claim to be “email killers”.
Lots of options, great to have choice, right?
But, it means we have to install multiple client apps on our
devices if we want to connect with people on different networks.
Friends on WhatsApp can’t communicate with friends on Signal.
And, as the fatigue of yet-another-app sets in, we can always
go back to that <a href="http://www.theatlantic.com/technology/archive/2014/08/why-email-will-never-die/375973/">dependable workhorse of the internet</a>, Email.</p>

<p>Email is <em>ubiquitous</em> - everyone has an email address. Email is
<em>interoperable</em> - friends on Hotmail can communicate with friends that
use Gmail. You can select your preferred service and still connect
with your friends on other services.
Email is <em>open</em> - you can run your own email server if you
don’t want to give up your data for someone else to farm/mine.</p>

<p>Just like <a href="https://twitter.com/timberners_lee/status/228960085672599552">Timbo</a> says “This is for everyone” about the web, email stands up as a symbol of the original <em>values</em> of the internet.
I first experienced the internet in the mid to late 90s. It was open and inclusive.
Everyone a creator, anyone a contributor.
The rest of the world, stuck in it’s scarcity mindset, looks for constant growth
as a sign of success. The internet took a more abundant view.
It birthed the open-source movement and creative commons.
And, this has spread beyond the internet as organisations
start to adopt new ways of working. But, the closed off, growth mindset
has spread to the internet. Startups, backed by venture capitalists seeking
growth and platform monopoly, create these apps. Of course, it doesn’t make
sense for them to think in a more global, interoperable, abundant, sustainable way.
Instead they have to <em>capture</em> a market. Email doesn’t fit into this view.
It doesn’t have one company promoting it.</p>

<p>Email does have it’s issues. It’s pretty broken. Spam is a huge problem,
but there are some great solutions, and with sender verification you can
limit your view of received communication as you can on the other
walled-garden apps.
Email also suffers because it has been used for so many different things.
We use it to aggregate news (newsletters and alerts), to verify our
identity, to authenticate and login to websites, and to share files.
All of these can be replaced with more modern alternatives. There are better
ways to share files. There are better ways to manage your todo list than
using your inbox. There are better ways to consume news and get updates from
our networks.</p>

<p>Despite it’s issues, and the fact that it doesn’t have any one company promoting
it, it’s not going away.
There are innovations happening.
It’s very hard for innovations to gain wide adoption, and they have to be
backward-compatible, but it is possible.
There are examples of <em>progressive enhancement</em> like the addition of the
<a href="http://www.list-unsubscribe.com/">List-Unsubscribe</a> header. There are also
examples of <em>conventions</em> such as how <a href="https://github.com/blog/1214-notification-email-improvements">GitHub</a> uses
mail headers to signal message importance, which work well with features
such as Gmail’s <a href="https://support.google.com/mail/answer/47787?hl=en">mute</a>
and importance indicator features.</p>

<h2 id="why-php">Why PHP?</h2>

<p>I’d love to see more innovative things done with email. But, the
complex specifications can put people off working with it.
I know PHP wasn’t designed for things like this, but I figured that
if I could do this in PHP, it might make smtp more accessible to
more developers.</p>

<p>I’m using <a href="http://reactphp.org/">React PHP</a> to do Event-driven,
non-blocking I/O.
This has nothing to do with Facebook’s front end framework called
React. This is an implementation of an event loop, based on the reactor pattern.
If you’re used to Node.js this will be familiar.</p>

<p>React PHP can work with basic PHP out of the box, but you’ll get more
performance if you have either libev or libevent extensions installed.</p>

<p>This is a basic SMTP server. It doesn’t have a huge array of features.
Initially I just want to be able to receive emails.</p>

<p>One simple use case for this is to run on your dev box to intercept emails
being sent from your development environment.
For example, you could configure Drupal to send email to this server and catch
all outgoing messages.</p>

<p>You could also set it up on a ‘reply-to’ address, and use it to catch
replies to transactional emails sent via a third-party email service.</p>

<h2 id="smtp-walkthrough">SMTP Walkthrough</h2>

<p>The first thing to understand is that SMTP defines the <em>envelope</em> that
messages get sent in, and not the content. There are other specifications
for the messages, SMTP just deals with moving the mail around the internet.
This process, called <em>relaying</em>, is about one process <em>transferring responsibility</em>
for the message to another.
This is key to understand, that it’s about passing on the <em>responsibility</em> for
the message to someone else, until the message reaches it’s intended recipient.</p>

<p>Here’s an example:</p>

<div class="figure">
<img src="/img/smtp/mail-flow.png" alt="smtp mail flow" />
</div>

<p>The mail client app running on the user’s device connects to the outbound
smtp server of their chosen email provider. The app authenticates the user,
and the server accepts responsibility for delivering the message.
It then looks up the destination mail server (via MX records in DNS)
and attempts to pass on the responsibility for the message. If it fails to do
this it must notify back along the <em>return path</em> of the message (back to where it
accepted the message from).</p>

<p>There are different types of SMTP server that take on different roles.
<em>Originator</em> servers create and put messages into the mail system.
<em>Delivery</em> servers are responsible for receiving mail, taking them out of the
mail system and delivering to a mailbox.
This destination may not be on the same network, so a <em>relay</em> server passes
messages on to a server on another network. In the end the message, once the
message finds it’s way to the destination, it is places in a <em>mailbox</em>. SMTP
is done now. Other protocols, such as POP and IMAP, are used by clients to
access the messages in mailboxes.</p>

<p>As messages get transferred (relayed) they move from one system to another.
Let’s look at this process in more detail and look at a single SMTP
<em>conversation</em>. This is what it looks like…</p>

<div class="figure">
<img src="/img/smtp/smtp-conversation.png" alt="smtp conversation" />
</div>

<p>The <em>conversation</em> happens between a client and server. You might see this
referred to as sender and receiver, but the specifications talk about clients
and servers, so that’s the convention I use here.</p>

<p>The server listens for connections on a socket. The default port for SMTP
is port 25. Port 587, known as the submission port, is also used, by mail clients
when first getting messages into the <em>mail system</em>.</p>

<p>In the example conversation above, you can see that the server has taken on
the responsibility of delivering the message. It agreed to this, and the
client can now forget about this message.
But, things don’t always go according to plan. Sometimes the server can’t
deliver, or doesn’t want to accept a message. There are two types of
failure, temporary and permanent. If the server indicates either of these
failures to the client, then the client is still responsible for the email.
In the case of temporary failure, the client can come back later and try
again. For permanent failure, the client has to report back up the
<em>return path</em>. It may also give up on messages that get too many
temporary failures.</p>

<p>The SMTP conversation consists of a series of requests sent from the client
and responses sent by the server. Each request from the client is a <em>command</em>
which the server tries to obey, and then sends it’s response.
A <em>transaction</em> is a series of commands that specify where the email is coming
from, who it’s to be delivered to, and the content of the message.
The server responses to
each command with a status code that indicates if the command was accepted,
or if a temporary or permanent error has occurred. After a transaction the
client can continue the conversation and send another message if it has more
for that server. Or, it can request to close the connection.</p>

<p>The conversation goes through various stages. These are:
Connection, Hello, Mail From, Recipient, Data, Encoded Message, Quit.</p>

<div class="figure">
<img src="/img/smtp/conversation.png" alt="smtp conversation detail" />
</div>

<p>There are many reasons why a server might reject a message. It might not
recognise the receiver. The mailbox could be full. It might be having issues
connecting to it’s database or storage backend. The server could just be very
overloaded with other work.
In the following chart you can see how a server can respond with temporary
or permanent error status at the various stages in the conversation.
The chart shows at what point the client should defer delivery, or class this
as a permanent failure.</p>

<div class="figure">
<img src="/img/smtp/deferred-or-failure.png" alt="chart of smtp deferred or failure status" />
</div>

<p>You may notice that there is a small chance of duplicated message delivery.
Imagine that the server accepts the encoded message but there is a network
failure and the server’s response doesn’t arrive. Now both servers think they
have responsibility for delivering the message.
To avoid this, servers should minimise the time between receiving the last bit
of the encoded message and sending the response accepting the message.
The server should avoid expensive operations at this point and, once accepted,
the mail should be queued for later processing and delivery.</p>

<h2 id="example-conversation">Example Conversation</h2>

<p>The conversation in the diagram above outlines how the client and server
communicate. Let’s have a look at what this conversation actually looks
like…</p>

<p>The client connects to the server, and the server replies with:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>220 mail.example.com ESMTP
</code></pre>
</div>

<p>The client then says hello…</p>

<div class="highlighter-rouge"><pre class="highlight"><code>HELO example.com
</code></pre>
</div>

<p>To which the server replies…</p>

<div class="highlighter-rouge"><pre class="highlight"><code>250 mail.example.com
</code></pre>
</div>

<p>The client then starts sending commands…</p>

<div class="highlighter-rouge"><pre class="highlight"><code>MAIL FROM:&lt;me@daz.is&gt;
</code></pre>
</div>

<p>After each command, the server responds with a status code…</p>

<div class="highlighter-rouge"><pre class="highlight"><code>250 ok
</code></pre>
</div>

<p>The conversation continues…</p>

<div class="highlighter-rouge"><pre class="highlight"><code>RCPT TO:&lt;test@darrenmothersele.com&gt;
250 ok
</code></pre>
</div>

<p>The client gets to the point where it is ready to transfer the message data…</p>

<div class="highlighter-rouge"><pre class="highlight"><code>DATA
</code></pre>
</div>

<p>The server responds…</p>

<div class="highlighter-rouge"><pre class="highlight"><code>354 go ahead
</code></pre>
</div>

<p>The client then sends the message, terminating in a line with a single <code class="highlighter-rouge">.</code>
(full stop)…</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Date: 17 Sept 2016 01:01:01 -0000
From: me@daz.is
To: test@darrenmothersele.com
Subject: testing your email server

Does this work?
.
</code></pre>
</div>

<p>The server accepts…</p>

<div class="highlighter-rouge"><pre class="highlight"><code>250 ok
</code></pre>
</div>

<p>Then the client requests to close the connection…</p>

<div class="highlighter-rouge"><pre class="highlight"><code>QUIT
</code></pre>
</div>

<p>And the server complies, after sending a final status message to
indicate everything was successful…</p>

<div class="highlighter-rouge"><pre class="highlight"><code>221 mail.example.com
</code></pre>
</div>

<p>You can clearly see from this conversation that the communication consists
of requests and responses.</p>

<p>Responses always have this format:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>XXX blah blah blah\r\n
</code></pre>
</div>

<p>Requests have this format:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>VERB [optional parameters] \r\n
</code></pre>
</div>

<p>Until the <code class="highlighter-rouge">DATA</code> command is sent, at which point the conversation switches
to a different mode where the server just receives lines of data until the client
indicates it is done by sending a line with a single <code class="highlighter-rouge">.</code> (full stop).</p>

<p>Notice the format of the requests and responses, and that we have two modes
(or states). In one state the server is receiving commands, in the other state
the server is receiving data. We’ll come back to this in more detail later.</p>

<h2 id="a-simple-smtp-server">A Simple SMTP Server</h2>

<p>Before I get into the details of receiving SMTP messages, I thought I would
specify what <em>isn’t</em> part of this system. By that I mean the actual
delivery of the incoming messages. This system is going to deal with the SMTP
bits, but some other code will be required to actually do something with the
messages.</p>

<p>I define an interface for what this code will do…</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php">interface MailHandlerInterface
{
    /**
     * @param string $address
     * @return bool
     */
    public function isMailboxAvailable($address);

    /**
     * @param Envelope $envelope
     * @return bool
     */
    public function deliver(Envelope $envelope);

}</code></pre></figure>

<p>Here is an basic example for testing purposes that just accepts
any messages and stores them into text files with random identifiers.</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php">class TestMailHandler implements MailHandlerInterface
{
    public function isMailboxAvailable($address)
    {
        return true;
    }

    public function deliver(\Smtpd\Envelope $envelope)
    {
        file_put_contents(__DIR__.'/../var/'.uniqid().'.txt', $envelope-&gt;getData());
        return true;
    }
}</code></pre></figure>

<p>Obviously you probably want to do something else with the message like queue
it for further processing, spam checking, etc. The only requirement is that
whatever you do, the deliver method should return as quickly as possible.</p>

<p>Here’s the main <code class="highlighter-rouge">smtpd.php</code> script…</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php">use React\Socket\Server;
use function EventLoop\getLoop;
use Smtpd\ConnectionHandler;

require_once __DIR__.'/../vendor/autoload.php';

$mailHandler = new TestMailHandler;

$socket = new Server(getLoop());
$socket-&gt;on('connection', new ConnectionHandler($mailHandler));
$socket-&gt;listen(2525);</code></pre></figure>

<p>Easy to follow so far?
All this does is…</p>

<ol>
  <li>Creates a socket server using React PHP.</li>
  <li>Tells the server, that on the <code class="highlighter-rouge">connection</code> event (i.e. for new connections)
 to pass them to our <code class="highlighter-rouge">ConnectionHandler</code>.</li>
  <li>Listen on port 2525</li>
</ol>

<p>NB: you would normally have to start the event loop, but I’m using the
<code class="highlighter-rouge">EventLoop</code> library to ensure that the loop is automatically started
at the end of the script.</p>

<p>This style of programming will be familiar if you’ve ever
used node.js - basically you provide a callback function, and that function
is called from the event loop whenever that event happens. In this case when
a new connection is made to the socket server it fires the <code class="highlighter-rouge">connection</code> event.
This is passed to our <code class="highlighter-rouge">ConnectionHandler</code>. We’re using a feature of PHP called
<em>invokable</em> objects to use this handler object as a callback. Basically, you
implement the <code class="highlighter-rouge">__invoke()</code> method in your class and you can use the objects
as if they were callback functions.</p>

<p>Here’s the <code class="highlighter-rouge">ConnectionHandler</code> class…</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php">class ConnectionHandler
{
    /** @var MailHandlerInterface */
    protected $mailHandler;

    /** @var string */
    protected $hostname;

    public function __construct(MailHandlerInterface $mailHandler, $hostname = '')
    {
        $this-&gt;mailHandler = $mailHandler;
        $this-&gt;hostname = $hostname ?: gethostname();
    }

    public function __invoke(Connection $connection)
    {
        $connection-&gt;write("220 {$this-&gt;hostname} Ready\r\n");
        $connection-&gt;on('data', new DataHandler($connection, $this-&gt;mailHandler, $this-&gt;hostname));
    }
}</code></pre></figure>

<p>You can see the <code class="highlighter-rouge">__invoke</code> method, which is the callback for the socket’s
<code class="highlighter-rouge">connection</code> event. It sends a response to the client, and then registers
a new callback for the <code class="highlighter-rouge">data</code> event. This will be where the socket sends
further data that it receives from the client.</p>

<p>This is our first example of a SMTP response. Let’s look at this in more
detail…</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php">"220 {$this-&gt;hostname} Ready\r\n"</code></pre></figure>

<p>The responses always start with three digits. This is the status code.
Like HTTP status codes, there are different classes of status code that
can be sent. 200-399 indicate acceptance.
Codes between 400-499 are a temporary rejection,
and codes between 500-599 indicate a permanent rejection.</p>

<p>A server can send a multi-line response. In which case the status code is
separated from the rest of the line by a <code class="highlighter-rouge">-</code> (dash). Only the last line
of the response has a space separating the status code from the rest of the
line. For example:</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php">"421-{$this-&gt;hostname} is too busy right now\r\n"
"421 please come back in 100 seconds.\r\n"</code></pre></figure>

<p>All lines in an SMTP conversation, terminate with <code class="highlighter-rouge">\r\n</code>.</p>

<p>This first response, on opening of the connection, is called the <em>greeting</em>
and is the server’s way of indicating that it is ready to receive connections.
It can also include details of the software versions used which can help
debug issues with mail delivery, but this could also been seen as a security risk.</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php">class DataHandler
{
    const VALID_COMMANDS = [
      'HELO', 'EHLO', 'NOOP', 'RSET', 'QUIT', 'MAIL', 'RCPT', 'DATA'
    ];

    const STATE_COMMAND = 0;
    const STATE_DATA = 1;

    /** @var int */
    protected $state = self::STATE_COMMAND;

    /** @var Connection */
    protected $connection;

    /** @var Envelope */
    protected $envelope;

    /** @var MailHandlerInterface */
    protected $mailHandler;

    /** @var string */
    protected $hostname;

    public function __construct(
        Connection $connection,
        MailHandlerInterface $mailHandler,
        $hostname
    ) {
        $this-&gt;connection = $connection;
        $this-&gt;mailHandler = $mailHandler;
        $this-&gt;envelope = new Envelope;
        $this-&gt;hostname = $hostname;
    }

    public function __invoke($data)
    {
        if ($this-&gt;state == self::STATE_DATA)
        {
            $this-&gt;processDataLine($data);
        }
        else
        {
            $this-&gt;processCommand($data);
        }
    }

    /** Rest of DataHandler class ... -- **/
}    </code></pre></figure>

<hr />

<p><small>
<b>Credits</b>:
I used some cc icons (from the <a href="https://thenounproject.com/">Noun Project</a>)
when creating the diagrams in this article:
Smartphone Mailbox by Myart, Server by Justin Blake, message database by Danil Polshin,
Robot by Artem Kovyazin.
</small></p>



<div class="author-line">

  <figure class="author-image">
    <img src="/img/darren100.jpg" alt="Darren's Photo" class="avatar">
  </figure>

<h4>Darren Mothersele</h4>
<p>Darren is a software developer who builds simple, creative, and independent technology. <a href="/about">Read more &raquo;</a></p>
</div>




<footer>
  <p>Want to support my work? Buy my <a href="/blog/2016/06/16/php-framework-weekend/">PHP Framework</a> book.
  Available in paperback from <a href="http://amzn.to/2bNv560">Amazon</a> or eBook from <a href="https://leanpub.com/phpframework">Leanpub</a>.</p>
  <p>
    <small>
      &copy;2007-2016 <a href="/about">Darren Mothersele</a>.
        <a class="text-white" href="http://creativecommons.org/licenses/by-sa/4.0/">Some rights reserved</a>.
        <a href="/contact">Contact</a>.
        <a href="/blog/">Blog Archive</a>.
    </small>
  </p>
</footer>
</body>
</html>
